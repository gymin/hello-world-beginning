How to create a histogram (quantitative dta): back to pokemon case

bins = np.arrange(0, pokemon['spped'].max()+5, 5) 
## first argumnet: min value, second argument: max, but we added +5 otherwise it will not include the actual max. value). 
## third argument: step-size for the bins (bins size) 
plt.hist(data = pokemon, x = 'speed', bins = bins); 
## output: based on basic bin range, so you can set up yours (e.g. bins)

## OR 
sb.distplot(pokemon['speed']); 
## ouptut shows a histogram and line starting from -25 to 175 
## 2 differences: 1. the default bin count is larger than in matplotlib, 
##                2. line plotting, but y value is a lot smaller, because the line is a density curve estimates of the data distribution
## you can turn off the density line by adding 'kde = False' at the end like below.. 
sb.distplot(pokemon['speed'], kde = False) 

# Default setting (Matplot)
plt.hist(data = df, x = 'num_var')
## but this divides the data into 10 bins, based on the range of values taken, but usulally having only 10 bins is too few to really understand the distribution 
## you can first check the min. and max value by using df['num_var'].describe(), then 
bin_edges = np.arange(0, df['num_var'].max()+1, 1)  ## arrange(min, max, bin_width)
plt.hist(data = df, x = 'num_var', bins = bin_edges)

plt.figure(figsize = [10, 5]) # larger figure size for subplots

# histogram on left, example of too-large bin size
plt.subplot(1, 2, 1) # 1 row, 2 cols, subplot 1  ## you can put two plots side by side through use of the subplot 
bin_edges = np.arange(0, df['num_var'].max()+4, 4)
plt.hist(data = df, x = 'num_var', bins = bin_edges)

# histogram on right, example of too-small bin size
plt.subplot(1, 2, 2) # 1 row, 2 cols, subplot 2
bin_edges = np.arange(0, df['num_var'].max()+1/4, 1/4)
plt.hist(data = df, x = 'num_var', bins = bin_edges)

# Default (Seaborn)
sb.distplot(df['num_var'])
## this has built-in rules for specifying histogram bins, and by default plots a curve depicting the kernel density estimate (KDE) on top of the data
## the vertical axis is based on the KDE, rather than the histogram 
## to show only a histogram 
bin_edges = np.arange(0, df['num_var'].max()+1, 1)
sb.distplot(df['num_var'], bins = bin_edges, kde = False,
            hist_kws = {'alpha' : 1})  ## alpha= transparency setting 
            
...................................................................................

# Extra: how subplots work 

## the base of a visualisation in matplotlib is a Figure object, following the three steps 
fig = plt.figure()  ## python, create an area for a figure to plot inside 
ax = fig.add_axes([.125, .125, .755, .755])  ## create axes: first two (the position of the lower-left hand corner of the axes: where x and y meet), last two (axes width and height)
ax.hist(data = df, x = 'num_var') ## now plot the data inside that axes
## for Seaborn, the last one would be... 
sb.countplot(data = df, x = 'num_var', ax = ax)

## if you don't assign Axes objects as they're created,you can retrieve the current Axes using, 'ax = plt.gca()'
## OR you can get a list of all Axes in a figure 'fig' by using 'axes = fig.get_axes()
## As for creating subplots, you can use 'fig.add_suplot()' in the same way as 'plt.subplot()' above 
fig, axes = plt.subplots(3, 4) # grid of 3x4 subplots
axes = axes.flatten() # reshape from 3x4 array into 12-element vector
for i in range(12):
    plt.sca(axes[i]) # set the current Axes
    plt.text(0.5, 0.5, i+1) # print conventional subplot index number to middle of Axes

